Control Flow
============


Where do I start?
-----------------
Surprisingly, the 6502 actually begins at the very end of the memory map, at
memory location ```$FFFA```, where the [[vector table|vector_table]] is
located.

The vector table is three words of memory that specify where the 6502 should
execute code when certain events occur.

    * ```$FFFA```: **Non-Maskable Interrupt** [[NMI|nmi]]
    * ```$FFFC```: **Reset**
    * ```$FFFE```: **Interrupt Request** [[IRQ|irq]]

We'll discuss the interrupts later - right now, we're more interested in
the reset vector. The reset vector is the label that the processor should jump
to whenever the NES is powered up or the reset button is pressed. Typically
we give this label a meaningful name, such as "start" or "reset". No matter
what code is written first, the code that is specified by this vector will be the
first code that is executed.

In order to specify our starting point, we use the [[.org|org]] directive near
the end of our code to tell the assembly to put data in the vector table.

    start:
        LDA #44
        ADC #1
        ;... more code
    
    ; At the end of the document...
    .org $FFFA      ; The .org directive tells the assembler to change where it
                    ; puts compiled code.
        .dw $0      ; The NMI vector, $FFFA
        .dw start   ; The reset vector, $FFFC
        .dw $0      ; The IRQ vector, $FFFE
                    ; The .dw directive (declare word) inserts literal bytes
                    ; into the binary of the program. .dw automatically reverses
                    ; the order of the bytes so that the smaller byte comes
                    ; first.

This program will begin by doing the very important task of putting 44 in the
accumulator, adding 1 to it, and going off and doing its thing. If we hit the
reset button, it will go back to that point and do it again.


Interrupts
----------
As we mentioned earlier, there are two kinds of interrupts... IRQs and NMIs.
But first, what's an interrupt?

Let's say you're cooking a pot of pasta, and it takes nine minutes to prepare.
One way of cooking it and making sure that it doesn't get overcooked is to write
down the time that it is supposed to be done and periodically check the clock
to see if that time has arrived. Another option is to set an egg timer to go off
in 9 minutes. While this may *interrupt* you while you are doing something else,
you don't have to worry about accidentally getting distracted and ending up with
soggy pasta.

The first approach here is called **polling** - polling is where you write a
program that does its own thing, and then periodically checks to see if it has
any messages. An **interrupt**, on the other hand, will tell the program "stop
whatever you're doing and deal with this"! Both have advantages and disadvantages -
any time you check for a message and there isn't one there, you've wasted time
you could have spent doing something more important. However, dealing with
interrupts requires you to spend time safely stopping the task you're working
on so you can deal with whatever needs your attention. In general, we use
Interrupts for the NES.

Now, once again, there are two types of Interrupts - IRQs and NMIs. Let's do
another analogy.

Let's say it's early on a saturday morning and your alarm goes off. You don't
really feel like waking up, so you hit the snooze button. Even though the
alarm would normally have interrupted you, you disregarded it and told it to
let you know later. A few minutes later, the fire alarm goes off. There's no
snooze button on this one, so you get up and head out of the building in your
pajamas and hope that it's just a prank.

In this example, the alarm clock is an **interrupt request** - it is a message
designed to tell you to stop what you're doing and do something else, but it
isn't urgent, and you can choose either to respond to it or disregard it. The
fire alarm is a **non-maskable interrupt** - an interrupt that is so important,
you can't just ignore it. The program must handle this interrupt, since it is
likely mission critical.

Whenever the 6502 receives a non-maskable interrupt (NMI), it jumps to the
memory location at ```$FFFA``` in the vector table. NMIs are generated by the
[[Picture Processing Unit|ppu]] whenever the screen refreshes, meaning that these
interrupts ensure that the framerate stays quick. When an IRQ is received and
serviced by the processor, the program jumps to the memory location at ```$FFFE```,
unless the [[interrupt]] flag has been set using the [[SEI|sei]] instruction
(the equivalent of the snooze button). IRQs are mostly produced by the
[[Audio Processing Unit|apu]] to keep the music on track. At then end of the
code handled by an Interrupt, use the [[RTI|rti]] instruction to go back to
where the code was before - more information about how to write interrupt
handling routines is explained in the
[[next part of this tutorial|subroutines_and_the_stack]].


Jumping and Branching
---------------------
We've already encountered jumping before - jumping is the act of changing the
value of the program counter in order to execute code at a different location
in the program. When using the [[JMP|jmp]] operation, the behavior of the
JMP is the same each time it is used.

A **branch**, on the other hand, is a special kind of jump that only takes
place when certain conditions are met, such as when a button is pressed on the
controller, or when the player runs out of lives. We've seen branches before
in previous tutorial pages. A branch is usually done after a [[comparison|cmp]].

        CMP #100        ; Compare the accumulator to 100. If equal, then
        BEQ new_life    ; get a new life.

The way that a comparison works is that it simulates a subtraction, and sets
the [[status]] flags as if the subtraction had occured. The status flags are
six bits on the processor that are set to indicate what happens when an
operation takes place. After every almost every operation on the 6502, up to
four status flags are affected.

 * The [[sign]] flag is set to True when the result of an operation can be
   considered a negative number (the most significant bit is 1).
 * The [[zero]] flag is set to True when the result of an operation is 0.
 * The [[carry]] flag is set to True when an unsigned overflow occurs during
   an addition operation (among others)
 * The [[overflow]] flag is only set after an addition or subtraction results
   in a signed overflow.

Because CMP simulates a subtraction, if the A register is equal to 100, then
A minus 100 will be equal to 0, and the zero flag will be set to True. The BEQ
operation (Branch on EQuals) performs the branch when the Zero flag is True, and
does nothing if the Zero flag is false.

There are eight branching opcodes, each branching based on different flags.
 * [[BPL|bpl]] Branch on PLus, branches if the sign flag is False
 * [[BMI|bmi]] Branch on MInus, branches if the sign flag is True
 * [[BVC|bvc]] Branch on oVerflow Clear, branches if the overflow flag is False
 * [[BVS|bvs]] Branch on oVerflow Set, branches if the overflow flag is True
 * [[BCC|bcc]] Branch on Carry Clear, branches if the carry flag is False
 * [[BCS|bcs]] Branch on Carry Set, branches if the carry flag is True
 * [[BNE|bne]] Branch on Not Equal, branches if the zero flag is False
 * [[BEQ|beq]] Branch on EQual, branches if the zero flag is True

So how, for example, would we do a "branch if less than?" Well, CMP simulates
a subtraction. As it says on the [[SBC|sbc]] page, the carry flag for subtraction
is 1 if a borrow does not occur, and a 0 if a borrow occurs. If you think about
subtraction, you only borrow when the number being subtracted (the argument) is
greater than the number being subtracted from (the accumulator).

In other words, the BCC operation is essentially like a "Branch if Less Than"
operation (branch if the A register compared less than the argument). The
opposite, therefore would be BCS, which is "Branch if Greater than *or Equal To*".
There are numbers of ways to take advantage of these flags for interesting types
of branches, but those are best discussed in more advanced reading material. For
now, the most important branches are the obvious ones, such as equality.

There's one little caveat about branching opcodes, and that is that branches
don't actually specify the memory address of the target. Instead, the branch
specifies a *relative* jump that will be added/subtracted to the the program
counter, meaning that it is only possible to branch either backwards or
forwards by about 124 bytes.

    loop:           ; Let's say this label is at $C010
        CMP #100    ;
        BEQ loop    ; The loop here will actually be set equal to negative 4,
                    ; not the address of the loop.

If the branch is too large, the assembler will give you an error and tell you
to use a JMP instead. If we wanted to rewrite the above code with a jump, the
way we would do so would be like this:

    loop:           ;
        CMP #100    ;
        BNE notloop ; First, we use the oppposite branch statement.
        JMP loop    ; We use the full jump if the ORIGINAL branch is true,
    notloop:        ; and skip over it if it is false.


Jump Tables
-----------



Navigation
----------
 * [[Next Tutorial|subroutines_and_the_stack]]
 * [[Back to Table of Contents|tutorial]]
 
