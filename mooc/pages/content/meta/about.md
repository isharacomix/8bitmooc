Welcome to #8bitmooc!
=====================
The best way to think about #8bitmooc is as a "history course with programming."
If you want to learn how to make games, there are much better and easier tools
that will help you make advanced games such as [GameMaker](http://yoyogames.com)
and [Unity3D](http://unity3d.com). It is a bit more difficult to use the NES
to make sophisticated programs, but it has been done to great success with too
many complicated and successful games to name here. This gets us to the whole
point of #8bitmooc:


Who is this course for?
-----------------------
If you think this course is only for people who are computer savvy, you are
**wrong**. This course is designed to be accessible to anyone, regardless of
their programming background, and while it's true that participants who have
programmed before will have an easier time *at first*, the course is entirely
self-paced, and there's no rush to get to the level you need in order to
understand where the couse is going.

This class is not designed to be easy. It's meant to be a challenge, since it
involves programming using technology that's essentially 20 years old. If you
don't have a programming background, then it will be even more challenging.
However, the idea behind this course is that the challenge is part of the
reward, and that the work will pay for itself in due time.

If you're interested in the history of technology or video games, or have ever
wanted to understand how hardware works, then there's something in this course
for you.


What will you learn
-------------------
This course will teach you how to develop 8-bit games for the NES. Now, you
may be wondering, "how will I ever use that skill?" However, there are a lot
of technical skills you will pick up along the way in order to make it that
far, such as...

 * How to write computer code
 * How hardware is organized
 * How programming languages compile to binary
 * How to read a spec sheet

That's not all - once you've learned the basics of the language, we can start
asking much more interesting questions. What were the limitations and affordances
of the NES, and how are they apparent in the games that were made in the 1980's?
How did the design of the instruction set of the 6502 position certain use-cases
above others for programmers? How did the choice of graphics and sound hardware
affect the way that programs would be written? These are topics that can't be
taught by automatically graded assignments, and can't be appreciated until
learning the basics of the programming paradigm.

**The primary goal of the class is to get you to solve problems using the same
tools and processes as game developers from the 1980's.**


How you will learn
------------------
We believe in learning by doing, and that goes beyond lecture videos and
multiple-choice quizzes. The most straightforward way to develop and test
your programming knowledge comes from #8bitmooc's assembly [[challenges]], which
give you a game that's *almost working*, and asks you to program the rest it.
You are responsible for teaching yourself what you need to learn in order to
successfully complete the challenge, which ensures that what you learn sticks
with you.

However, automatically graded exercises can only do so much. Part of learning
a computer language is learning how to explore it for yourself. For that reason,
a [[playground]] that allows you to program NES games from scratch is made
available to give you a safe sandbox to try out the techniques you learn from
readings, videos, and other students on the [[forums]]. It's even possible to
publish your games for others to play and learn from.


When am I done?
---------------
As soon as you can make an entire program from scratch on your own, you can
consider yourself finished with what this course has to offer you. You won't get
any credit or merit badges for completing the course - your reward will be the
knowledge it took to get you to this point.

You're done when you say you are. Even after you finish all of the challenges,
you're welcome to stay for as long as you like, writing programs, learning more
tricks, optimizing your programs, and interacting with others on the forums.

